%----- SE UTILIZO LA HERR Octave Online -------

% --- Definición de Parámetros Generales ---
% fs: Frecuencia de muestreo en Hz. Importante para la resolución de tiempo y frecuencia.
% T: Periodo de muestreo (1/fs).
% duration: Duración total de la simulación en segundos.
% t: Vector de tiempo para la simulación.

% --- 1. Generación de la Señal de Mensaje (Baja Frecuencia) ---
% fm: Frecuencia de la señal de mensaje (información a transmitir).
% Am: Amplitud máxima de la señal de mensaje.
% message_signal: Señal sinusoidal que representa el mensaje.

% --- 2. Implementación de la Modulación en Amplitud (AM) ---
% fc: Frecuencia de la señal portadora (alta frecuencia).
% Ac: Amplitud de la señal portadora.
% mu: Índice de modulación. Controla la profundidad de la modulación.
% carrier_signal: La onda sinusoidal de alta frecuencia.
% am_signal: La señal de mensaje modulada en amplitud.

% --- 3. Análisis del Impacto del Ruido ---
% desired_snr_db: Relación Señal a Ruido deseada en decibelios.
% signal_power: Potencia de la señal AM.
% noise_power: Potencia del ruido calculada para la SNR deseada.
% noise: Ruido blanco gaussiano generado.
% am_signal_noisy: Señal AM con ruido añadido.

% --- 4. Análisis del Impacto de la Distorsión ---
% distortion_coeff: Coeficiente que controla la severidad de la distorsión no lineal.
% am_signal_distorted: Señal AM después de aplicar distorsión cuadrática.

% --- 5. Análisis del Impacto de la Atenuación ---
% attenuation_factor: Factor por el cual se reduce la amplitud de la señal (0 a 1).
% am_signal_attenuated: Señal AM después de aplicar atenuación.

% --- Bloques de Visualización (figure, subplot, plot, title, xlabel, ylabel, grid on) ---
% Explicar brevemente qué muestra cada figura y sus subplots (dominio del tiempo vs. frecuencia).
% Señalar qué se espera observar en cada una (p. ej., envolvente, bandas laterales, piso de ruido, armónicas).
%------------------------------------------------------------------------------------------------------------


% 1.--- Parámetros de la señal de mensaje ---
fm = 10;        	% Frecuencia del mensaje en Hz
Am = 1;          	% Amplitud del mensaje

% --- Parámetros de muestreo ---
fs = 1000;      	% Frecuencia de muestreo en Hz (debe ser al menos 2*fc para evitar aliasing)
T = 1 / fs;     	% Periodo de muestreo
duration = 1;    	% Duración de la señal en segundos
t = 0:T:(duration-T); 	% Vector de tiempo (asegura que el último punto no exceda la duración)

% --- Crear la señal de mensaje (ejemplo: un seno) ---
	% se podría experimentar con otras formas de onda (coseno, suma de senos, etc.)
message_signal = Am * cos(2 * pi * fm * t);

% --- Graficar la Señal de Mensaje ---
figure(1); 		% Abre una nueva figura

subplot(2, 1, 1); 	% Divide la figura en 2 filas, 1 columna, y selecciona la primera
plot(t, message_signal);
title('Señal de Mensaje (Dominio del Tiempo)');
xlabel('Tiempo (s)');
ylabel('Amplitud');
grid on; 			% Añade una cuadrícula

% --- Graficar el Espectro de Frecuencia de la Señal de Mensaje ---
N = length(message_signal); 	% Número de puntos de la señal
yf = fft(message_signal);   	% Calcula la Transformada Rápida de Fourier (FFT)
xf = (0:N-1)*(fs/N);        	% Vector de frecuencias

	% Solo interesa la parte positiva del espectro
xf_positive = xf(1:N/2);
yf_positive = abs(yf(1:N/2))/(N/2); 	% Normalizar la magnitud

subplot(2, 1, 2);		% Selecciona la segunda subgráfica
plot(xf_positive, yf_positive);
title('Espectro de Frecuencia de la Señal de Mensaje');
xlabel('Frecuencia (Hz)');
ylabel('Magnitud');
xlim([0 fm*5]); 		% Limita el eje X para ver mejor el pico de frecuencia del mensaje
grid on;



% 2.--- Parámetros de la señal portadora ---
fc = 100;    			% Frecuencia de la portadora en Hz (debe ser mucho mayor que fm)
Ac = 1;      			% Amplitud de la portadora

% --- Índice de modulación ---
	% mu = k_a * Am. notar que mu <= 1 para evitar sobremodulación en AM convencional.
mu = 0.8;   			 % Índice de modulación (0 < mu <= 1)

% --- Crear la señal portadora ---
carrier_signal = Ac * cos(2 * pi * fc * t);

% --- Implementar la Modulación AM (DSB-WC) ---
	% s(t) = Ac * (1 + mu * (m(t)/Am)) * cos(2*pi*fc*t)
	% m(t)/Am normaliza el mensaje entre -1 y 1
am_signal = Ac * (1 + mu * (message_signal / Am)) .* carrier_signal; 		% El .* es importante para la multiplicación elemento a elemento

% --- Graficar la Señal AM Modulada ---
figure(2); 			% Abre una nueva figura para las señales moduladas

subplot(3, 1, 1); 		% 3 filas, 1 columna, primera gráfica
plot(t, message_signal, 'b--', 'DisplayName', 'Señal de Mensaje');	 	% Mensaje en línea discontinua
hold on; 			% Permite agregar más elementos a la misma gráfica
plot(t, am_signal, 'r', 'DisplayName', 'Señal AM Modulada'); 			% Señal AM
	% Graficar la envolvente para una mejor visualización
upper_envelope = Ac * (1 + mu * (message_signal / Am));
lower_envelope = -Ac * (1 + mu * (message_signal / Am));
plot(t, upper_envelope, 'g:', 'LineWidth', 1, 'DisplayName', 'Envolvente Superior');
plot(t, lower_envelope, 'g:', 'LineWidth', 1, 'DisplayName', 'Envolvente Inferior');
hold off; 			% Termina de agregar elementos
title('Señal AM Modulada (Dominio del Tiempo)');
xlabel('Tiempo (s)');
ylabel('Amplitud');
xlim([0 0.2]); 			% Mostrar solo una pequeña porción para apreciar los detalles
grid on;
legend('Location', 'northeast'); 	% Muestra la leyenda

% --- Gráfica de la Portadora (para comparación) ---
subplot(3, 1, 2);
plot(t, carrier_signal, 'm');
title('Señal Portadora (Dominio del Tiempo)');
xlabel('Tiempo (s)');
ylabel('Amplitud');
xlim([0 0.2]); 			% Mostrar solo una pequeña porción
grid on;

% --- Graficar el Espectro de Frecuencia de la Señal AM Modulada ---
N_am = length(am_signal);
yf_am = fft(am_signal);
xf_am = (0:N_am-1)*(fs/N_am);

xf_am_positive = xf_am(1:N_am/2);
yf_am_positive = abs(yf_am(1:N_am/2))/(N_am/2); 	% Normalizar la magnitud

subplot(3, 1, 3);
plot(xf_am_positive, yf_am_positive);
title('Espectro de Frecuencia de la Señal AM Modulada');
xlabel('Frecuencia (Hz)');
ylabel('Magnitud');
xlim([0 fc * 2]); 		% Enfocarse en las frecuencias relevantes: portadora y bandas laterales
grid on;



% 3.--- Introducir Ruido en la Señal AM ---

	% Calcular la potencia de la señal modulada (asumiendo que tiene media cero para simplificar)
	% Si la señal tiene un offset (como AM, que es positiva), es mejor calcular la potencia de la señal AC o RMS.
	% Para fines de simulación de ruido, se basará en la varianza.
	% Una forma de estimar la potencia de la señal es la varianza (para señales de media cero) o P = mean(signal.^2)
signal_power = mean(am_signal.^2); 	% Potencia de la señal AM

	% Definir la relación señal a ruido (SNR) deseada en dB
	% Un SNR más alto significa menos ruido; un SNR más bajo significa más ruido.
desired_snr_db = 10; 			% SNR deseado en dB (se puede experimentar con 20, 10, 5, 0, -5, etc.)

	% Convertir SNR de dB a una relación lineal
desired_snr_linear = 10^(desired_snr_db / 10);

	% Calcular la potencia de ruido necesaria
noise_power = signal_power / desired_snr_linear;

	% Calcular la desviación estándar del ruido gaussiano
	% std_dev = sqrt(variance). Para ruido blanco gaussiano, la potencia es igual a la varianza.
noise_std_dev = sqrt(noise_power);

	% Generar ruido blanco gaussiano
	% La función randn() en Octave/MATLAB para generar números aleatorios con distribución normal (media 0, varianza 1).
	% Multiplicamos por la desviación estándar calculada para obtener la potencia de ruido deseada.
noise = noise_std_dev * randn(size(am_signal));

	% Añadir el ruido a la señal AM
am_signal_noisy = am_signal + noise;

% --- Graficar la Señal AM con Ruido (Dominio del Tiempo y Frecuencia) ---
figure(3); 			% Abre una nueva figura para las señales con ruido

subplot(2, 1, 1);
plot(t, am_signal_noisy, 'r');
hold on;
	% Para comparar, puedes graficar también la envolvente original
upper_envelope = Ac * (1 + mu * (message_signal / Am));
lower_envelope = -Ac * (1 + mu * (message_signal / Am));
plot(t, upper_envelope, 'g:', 'LineWidth', 1);
plot(t, lower_envelope, 'g:', 'LineWidth', 1);
hold off;
title(sprintf('Señal AM Modulada con Ruido (SNR = %d dB)', desired_snr_db));
xlabel('Tiempo (s)');
ylabel('Amplitud');
xlim([0 0.2]); 			% Mostrar una porción para ver el efecto del ruido
grid on;

subplot(2, 1, 2);
N_noisy = length(am_signal_noisy);
yf_noisy = fft(am_signal_noisy);
xf_noisy = (0:N_noisy-1)*(fs/N_noisy);

xf_noisy_positive = xf_noisy(1:N_noisy/2);
yf_noisy_positive = abs(yf_noisy(1:N_noisy/2))/(N_noisy/2);

plot(xf_noisy_positive, yf_noisy_positive);
title('Espectro de Frecuencia de la Señal AM con Ruido');
xlabel('Frecuencia (Hz)');
ylabel('Magnitud');
xlim([0 fc * 2]); 		% Enfocarse en las frecuencias relevantes
ylim([0 max(yf_am_positive)*1.2]); 	% Ajustar el límite Y para ver el ruido en el espectro
grid on;



% 4.--- Introducir Distorsión en la Señal AM ---

	% Partimos de la señal AM *sin ruido* para ver el efecto puro de la distorsión
	% Se experimenta añadiendo distorsión a la señal con ruido también.
signal_to_distort = am_signal; 		% O am_signal_noisy paraa ver distorsión + ruido

	% Coeficiente de distorsión (experimento con este valor)
	% Un valor pequeño (ej. 0.1) para distorsión leve.
	% Un valor mayor (ej. 0.5) para distorsión significativa.
distortion_coeff = 0.2;

	% Aplicar distorsión cuadrática (ejemplo de no linealidad)
	% y(t) = x(t) + alpha * x(t)^2
am_signal_distorted = signal_to_distort + distortion_coeff * (signal_to_distort.^2);

% --- Graficar la Señal AM con Distorsión (Dominio del Tiempo y Frecuencia) ---
figure(4); 			% Nueva figura para la distorsión

subplot(2, 1, 1);
plot(t, am_signal_distorted, 'b');
hold on;
	% Graficar la señal original sin distorsión para comparación
plot(t, signal_to_distort, 'r:', 'LineWidth', 1);
hold off;
title(sprintf('Señal AM Modulada con Distorsión (Coef: %.1f)', distortion_coeff));
xlabel('Tiempo (s)');
ylabel('Amplitud');
xlim([0 0.2]);
grid on;
legend('Señal Distorsionada', 'Señal Original AM', 'Location', 'northeast');

subplot(2, 1, 2);
N_distorted = length(am_signal_distorted);
yf_distorted = fft(am_signal_distorted);
xf_distorted = (0:N_distorted-1)*(fs/N_distorted);

xf_distorted_positive = xf_distorted(1:N_distorted/2);
yf_distorted_positive = abs(yf_distorted(1:N_distorted/2))/(N_distorted/2);

plot(xf_distorted_positive, yf_distorted_positive);
title('Espectro de Frecuencia de la Señal AM con Distorsión');
xlabel('Frecuencia (Hz)');
ylabel('Magnitud');
xlim([0 fc * 3]); 		% Ampliar para ver posibles nuevas armónicas
grid on;




% 5.--- Introducir Atenuación en la Señal AM ---

	% Partiendo de la señal AM original o con ruido/distorsión para combinar efectos
signal_to_attenuate = am_signal; 		% O am_signal_noisy, am_signal_distorted

	% Factor de atenuación (0 a 1)
	% Un valor de 0.5 reduce la amplitud a la mitad.
	% Un valor de 0.1 significa una atenuación muy fuerte.
attenuation_factor = 0.5; 			% Experimento con valores como 0.8, 0.5, 0.1

	% Aplicar atenuación
am_signal_attenuated = attenuation_factor * signal_to_attenuate;

% --- Graficar la Señal AM Atenuada (Dominio del Tiempo) ---
figure(5); 			% Nueva figura para la atenuación

subplot(2, 1, 1);
plot(t, signal_to_attenuate, 'r:', 'LineWidth', 1, 'DisplayName', 'Señal Original AM');
hold on;
plot(t, am_signal_attenuated, 'b', 'DisplayName', 'Señal AM Atenuada');
hold off;
title(sprintf('Señal AM Modulada con Atenuación (Factor: %.1f)', attenuation_factor));
xlabel('Tiempo (s)');
ylabel('Amplitud');
xlim([0 0.2]);
grid on;
legend('Location', 'northeast');

	% El espectro de frecuencia solo mostrará una reducción en la magnitud de los picos,
	% para eso el enfocque en el dominio del tiempo para la atenuación.
subplot(2, 1, 2);
N_attenuated = length(am_signal_attenuated);
yf_attenuated = fft(am_signal_attenuated);
xf_attenuated = (0:N_attenuated-1)*(fs/N_attenuated);

xf_attenuated_positive = xf_attenuated(1:N_attenuated/2);
yf_attenuated_positive = abs(yf_attenuated(1:N_attenuated/2))/(N_attenuated/2);

plot(xf_attenuated_positive, yf_attenuated_positive);
title('Espectro de Frecuencia de la Señal AM Atenuada');
xlabel('Frecuencia (Hz)');
ylabel('Magnitud');
xlim([0 fc * 2]);
grid on;


